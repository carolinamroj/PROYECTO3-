  .data
array:  .word 29, 10, 14, 37, 13, 5, 2, 20
n:      .word 8

        .text
        .globl _start
_start:

        # Cargar tamaño del arreglo en x1
        la x5, n        # x5 = dirección de n
        lw x1, 0(x5)    # x1 = n

        # x2 = i = 0
        add x2, x0, x0

outer_loop:
        bge x2, x1, end_program  # if i >= n, terminar

        # min_index = i
        add x3, x2, x0

        # j = i + 1
        addi x4, x2, 1

inner_loop:
        bge x4, x1, swap_elements  # if j >= n, ir a intercambio

        # offset_j = j * 4
        slli x5, x4, 2

        # dirección array[j]
        la x6, array
        add x5, x5, x6

        # cargar array[j]
        lw x7, 0(x5)

        # offset_min = min_index * 4
        slli x8, x3, 2
        la x9, array
        add x8, x8, x9

        # cargar array[min_index]
        lw x10, 0(x8)

        blt x7, x10, update_min_inner
        j inner_continue

update_min_inner:
        add x3, x4, x0  # min_index = j

inner_continue:
        addi x4, x4, 1
        j inner_loop

swap_elements:
        beq x2, x3, next_outer  # si i == min_index, saltar intercambio

        # intercambiar array[i] y array[min_index]
        slli x5, x2, 2
        la x6, array
        add x5, x5, x6
        lw x7, 0(x5)   # x7 = array[i]

        slli x8, x3, 2
        la x9, array
        add x8, x8, x9
        lw x10, 0(x8)  # x10 = array[min_index]

        sw x10, 0(x5)
        sw x7, 0(x8)

next_outer:
        addi x2, x2, 1
        j outer_loop

end_program:
        # Detener simulador
        addi x10, x0, 10
        ecall
